<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CoMusic ‚Ä¢ Upload para Cloudflare CDN</title>
  <style>
    :root {
      --bg: #0b0c10;
      --panel: rgba(18, 20, 28, 0.92);
      --panel-2: rgba(255, 255, 255, 0.04);
      --border: rgba(255, 255, 255, 0.1);
      --text: #f5f5f7;
      --muted: #a0a3b2;
      --accent: #ff2d7a;
      --ok: #29d17d;
      --warn: #ffb020;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", Arial, sans-serif;
      color: var(--text);
      background:
        radial-gradient(circle at top right, rgba(255, 45, 122, 0.2), transparent 45%),
        radial-gradient(circle at top left, rgba(80, 120, 255, 0.2), transparent 40%),
        var(--bg);
      min-height: 100vh;
    }

    header {
      position: sticky;
      top: 0;
      z-index: 10;
      backdrop-filter: blur(14px);
      background: rgba(12, 13, 18, 0.8);
      border-bottom: 1px solid var(--border);
      padding: 14px 18px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    header h1 {
      margin: 0;
      font-size: 18px;
      font-weight: 700;
    }

    header a {
      color: var(--text);
      text-decoration: none;
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 999px;
      font-size: 13px;
    }

    .layout {
      width: min(1200px, 96%);
      margin: 16px auto 30px;
      display: grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 14px;
    }

    .card {
      border: 1px solid var(--border);
      border-radius: 16px;
      background: var(--panel);
      padding: 14px;
    }

    h2 {
      margin: 0 0 10px;
      font-size: 16px;
    }

    .hint {
      color: var(--muted);
      font-size: 13px;
      margin: 0 0 10px;
      line-height: 1.4;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }

    .full { grid-column: 1 / -1; }

    label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 5px;
      font-weight: 600;
    }

    input, textarea, select {
      width: 100%;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--panel-2);
      color: var(--text);
      padding: 10px;
      font-size: 14px;
    }

    textarea { min-height: 90px; resize: vertical; }

    .actions {
      margin-top: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    button {
      cursor: pointer;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--panel-2);
      color: var(--text);
      padding: 10px 14px;
      font-weight: 600;
    }

    button.primary {
      background: var(--accent);
      border-color: transparent;
      color: #fff;
    }

    .status {
      margin-top: 10px;
      border-radius: 10px;
      padding: 10px;
      font-size: 13px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.03);
    }

    .status.ok { border-color: rgba(41, 209, 125, .45); }
    .status.warn { border-color: rgba(255, 176, 32, .5); }

    .queue-item {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
      margin-bottom: 8px;
      background: rgba(255,255,255,.02);
    }

    .queue-item h4 {
      margin: 0 0 3px;
      font-size: 14px;
    }

    .queue-item small {
      color: var(--muted);
      display: block;
      margin-bottom: 8px;
    }

    .tag {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      font-size: 12px;
      margin-right: 5px;
      margin-bottom: 5px;
    }

    pre {
      margin: 0;
      background: #06070b;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
      overflow: auto;
      max-height: 480px;
      font-size: 12px;
      line-height: 1.35;
    }

    @media (max-width: 960px) {
      .layout { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <header>
    <h1>üì§ CoMusic ‚Ä¢ Upload Manager (Cloudflare CDN)</h1>
    <a href="menu.html">Abrir player</a>
  </header>

  <main class="layout">
    <section class="card">
      <h2>1) Configura√ß√£o de Upload (Cloudflare)</h2>
      <p class="hint">
        Agora este painel suporta dois modos:<br>
        <strong>Direto S3 Presigned (recomendado para evitar "Failed to fetch")</strong> ou
        <strong>Assinado</strong> via backend <code>/sign-upload</code>.
      </p>

      <div class="grid">
        <div>
          <label for="uploadMode">Modo de upload</label>
          <select id="uploadMode">
            <option value="direct_s3">Direto S3 Presigned (browser)</option>
            <option value="signed">Assinado (backend /sign-upload)</option>
          </select>
        </div>
        <div>
          <label for="cdnPrefix">Prefixo p√∫blico CDN</label>
          <input id="cdnPrefix" placeholder="https://pub-xxxx.r2.dev" />
        </div>
        <div>
          <label for="cfAccountId">Cloudflare Account ID</label>
          <input id="cfAccountId" placeholder="ex.: 3f3d..." />
        </div>
        <div>
          <label for="cfBucket">Bucket R2</label>
          <input id="cfBucket" placeholder="nome-do-bucket" />
        </div>
        <div class="full">
          <label for="r2Endpoint">Endpoint S3 R2</label>
          <input id="r2Endpoint" placeholder="https://<accountid>.r2.cloudflarestorage.com" />
        </div>
        <div>
          <label for="r2AccessKeyId">Access Key ID (S3)</label>
          <input id="r2AccessKeyId" placeholder="chave de acesso S3" />
        </div>
        <div>
          <label for="r2SecretAccessKey">Secret Access Key (S3)</label>
          <input id="r2SecretAccessKey" placeholder="chave secreta S3" />
        </div>
        <div class="full">
          <label for="cfApiToken">API Token (opcional, legado)</label>
          <input id="cfApiToken" placeholder="usado apenas no modo direto legado" />
        </div>
        <div class="full">
          <label for="apiBase">Base URL da API (somente modo assinado)</label>
          <input id="apiBase" placeholder="https://seu-worker.exemplo.workers.dev/api" />
        </div>
        <div class="full">
          <label for="authToken">Bearer token para backend (opcional)</label>
          <input id="authToken" placeholder="token opcional" />
        </div>
      </div>

      <div class="actions">
        <button id="saveConfigBtn">Salvar configura√ß√£o local</button>
      </div>
      <div id="configStatus" class="status">Configura√ß√£o ainda n√£o salva.</div>
    </section>

    <section class="card">
      <h2>Preview do novo `musicas.json`</h2>
      <p class="hint">Adicione faixas na fila e gere JSON final para publicar no site.</p>
      <pre id="jsonPreview">{
  "albuns": [],
  "playlists": [],
  "placeholderArtista": ""
}</pre>
      <div class="actions">
        <button id="refreshPreviewBtn">Atualizar preview</button>
        <button id="downloadJsonBtn">Baixar musicas.json</button>
      </div>
    </section>

    <section class="card">
      <h2>2) Dados da faixa para upload</h2>
      <div class="grid">
        <div>
          <label for="albumTitle">√Ålbum</label>
          <input id="albumTitle" placeholder="Ex.: Kpop Demon Hunters" />
        </div>
        <div>
          <label for="albumCoverFile">Capa do √°lbum (imagem)</label>
          <input id="albumCoverFile" type="file" accept="image/*" />
        </div>

        <div>
          <label for="trackTitle">T√≠tulo da faixa</label>
          <input id="trackTitle" placeholder="Ex.: Golden" />
        </div>
        <div>
          <label for="trackArtist">Artista</label>
          <input id="trackArtist" placeholder="Ex.: HUNTRX" />
        </div>

        <div>
          <label for="audioFile">Arquivo de √°udio</label>
          <input id="audioFile" type="file" accept="audio/*" />
        </div>
        <div>
          <label for="videoFile">Arquivo de v√≠deo (opcional)</label>
          <input id="videoFile" type="file" accept="video/*" />
        </div>

        <div class="full">
          <label for="artistImageFile">Imagem do artista (opcional)</label>
          <input id="artistImageFile" type="file" accept="image/*" />
        </div>
      </div>

      <div class="actions">
        <button id="addQueueBtn">Adicionar na fila</button>
        <button id="clearFormBtn">Limpar formul√°rio</button>
      </div>
      <div id="formStatus" class="status">Preencha os campos para adicionar faixas.</div>
    </section>

    <section class="card">
      <h2>3) Fila e upload</h2>
      <div id="queueList"></div>
      <div class="actions">
        <button id="uploadAllBtn" class="primary">Enviar tudo para CDN (Cloudflare)</button>
        <button id="clearQueueBtn">Limpar fila</button>
      </div>
      <div id="uploadStatus" class="status warn">Nenhum upload iniciado.</div>
    </section>
  </main>

  <script>
    const state = {
      queue: [],
      musicData: {
        albuns: [],
        playlists: [],
        placeholderArtista: ''
      }
    };

    const el = {
      uploadMode: document.getElementById('uploadMode'),
      apiBase: document.getElementById('apiBase'),
      authToken: document.getElementById('authToken'),
      cdnPrefix: document.getElementById('cdnPrefix'),
      cfAccountId: document.getElementById('cfAccountId'),
      cfApiToken: document.getElementById('cfApiToken'),
      cfBucket: document.getElementById('cfBucket'),
      r2Endpoint: document.getElementById('r2Endpoint'),
      r2AccessKeyId: document.getElementById('r2AccessKeyId'),
      r2SecretAccessKey: document.getElementById('r2SecretAccessKey'),
      saveConfigBtn: document.getElementById('saveConfigBtn'),
      configStatus: document.getElementById('configStatus'),

      albumTitle: document.getElementById('albumTitle'),
      albumCoverFile: document.getElementById('albumCoverFile'),
      trackTitle: document.getElementById('trackTitle'),
      trackArtist: document.getElementById('trackArtist'),
      audioFile: document.getElementById('audioFile'),
      videoFile: document.getElementById('videoFile'),
      artistImageFile: document.getElementById('artistImageFile'),
      addQueueBtn: document.getElementById('addQueueBtn'),
      clearFormBtn: document.getElementById('clearFormBtn'),
      formStatus: document.getElementById('formStatus'),

      queueList: document.getElementById('queueList'),
      uploadAllBtn: document.getElementById('uploadAllBtn'),
      clearQueueBtn: document.getElementById('clearQueueBtn'),
      uploadStatus: document.getElementById('uploadStatus'),

      jsonPreview: document.getElementById('jsonPreview'),
      refreshPreviewBtn: document.getElementById('refreshPreviewBtn'),
      downloadJsonBtn: document.getElementById('downloadJsonBtn')
    };

    function headersWithAuth(json = true) {
      const h = {};
      if (json) h['Content-Type'] = 'application/json';
      const token = el.authToken.value.trim();
      if (token) h['Authorization'] = `Bearer ${token}`;
      return h;
    }

    function setStatus(node, text, type = '') {
      node.className = `status ${type}`.trim();
      node.textContent = text;
    }

    function persistConfig() {
      localStorage.setItem('comusicUploadConfig', JSON.stringify({
        uploadMode: el.uploadMode.value,
        apiBase: el.apiBase.value.trim(),
        authToken: el.authToken.value.trim(),
        cdnPrefix: el.cdnPrefix.value.trim(),
        cfAccountId: el.cfAccountId.value.trim(),
        cfApiToken: el.cfApiToken.value.trim(),
        cfBucket: el.cfBucket.value.trim(),
        r2Endpoint: el.r2Endpoint.value.trim(),
        r2AccessKeyId: el.r2AccessKeyId.value.trim(),
        r2SecretAccessKey: el.r2SecretAccessKey.value.trim()
      }));
      setStatus(el.configStatus, 'Configura√ß√£o salva no navegador.', 'ok');
    }

    function loadConfig() {
      const raw = localStorage.getItem('comusicUploadConfig');
      if (!raw) return;
      try {
        const cfg = JSON.parse(raw);
        el.uploadMode.value = cfg.uploadMode || 'direct_s3';
        el.apiBase.value = cfg.apiBase || '';
        el.authToken.value = cfg.authToken || '';
        el.cdnPrefix.value = cfg.cdnPrefix || '';
        el.cfAccountId.value = cfg.cfAccountId || '3f3d9fcf69cf8db418e97acb119b980a';
        el.cfApiToken.value = cfg.cfApiToken || '-Fj-NJDsUSeQ_1JuRMeaxU52chrpYmkZeoLpDFsM';
        el.cfBucket.value = cfg.cfBucket || '';
        el.r2Endpoint.value = cfg.r2Endpoint || 'https://3f3d9fcf69cf8db418e97acb119b980a.r2.cloudflarestorage.com';
        el.r2AccessKeyId.value = cfg.r2AccessKeyId || '';
        el.r2SecretAccessKey.value = cfg.r2SecretAccessKey || '';
        setStatus(el.configStatus, 'Configura√ß√£o carregada do navegador.', 'ok');
      } catch {
        setStatus(el.configStatus, 'Falha ao carregar config local.', 'warn');
      }
    }


    function getUploadConfig() {
      return {
        mode: el.uploadMode.value,
        apiBase: el.apiBase.value.trim(),
        authToken: el.authToken.value.trim(),
        cdnPrefix: el.cdnPrefix.value.trim(),
        accountId: el.cfAccountId.value.trim(),
        apiToken: el.cfApiToken.value.trim(),
        bucket: el.cfBucket.value.trim(),
        r2Endpoint: el.r2Endpoint.value.trim(),
        r2AccessKeyId: el.r2AccessKeyId.value.trim(),
        r2SecretAccessKey: el.r2SecretAccessKey.value.trim()
      };
    }


    const textEncoder = new TextEncoder();

    async function sha256Hex(text) {
      const data = typeof text === 'string' ? textEncoder.encode(text) : text;
      const hash = await crypto.subtle.digest('SHA-256', data);
      return [...new Uint8Array(hash)].map(b => b.toString(16).padStart(2, '0')).join('');
    }

    async function hmacSha256Raw(keyBytes, message) {
      const key = await crypto.subtle.importKey('raw', keyBytes, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
      return new Uint8Array(await crypto.subtle.sign('HMAC', key, textEncoder.encode(message)));
    }

    function toAmzDate(date = new Date()) {
      const iso = date.toISOString().replace(/[:-]|\.\d{3}/g, '');
      return { amzDate: iso.slice(0, 15) + 'Z', shortDate: iso.slice(0, 8) };
    }

    async function createR2PresignedPutUrl({ endpoint, bucket, objectKey, accessKeyId, secretAccessKey, expires = 900 }) {
      const endpointUrl = new URL(endpoint.replace(/\/$/, '') + '/' + encodeURIComponent(bucket) + '/' + objectKey.split('/').map(encodeURIComponent).join('/'));
      const host = endpointUrl.host;
      const { amzDate, shortDate } = toAmzDate();
      const region = 'auto';
      const service = 's3';
      const scope = `${shortDate}/${region}/${service}/aws4_request`;

      const params = new URLSearchParams({
        'X-Amz-Algorithm': 'AWS4-HMAC-SHA256',
        'X-Amz-Credential': `${accessKeyId}/${scope}`,
        'X-Amz-Date': amzDate,
        'X-Amz-Expires': String(expires),
        'X-Amz-SignedHeaders': 'host'
      });

      const canonicalQuery = params.toString();
      const canonicalRequest = [
        'PUT',
        endpointUrl.pathname,
        canonicalQuery,
        `host:${host}\n`,
        'host',
        'UNSIGNED-PAYLOAD'
      ].join('\n');

      const hashedCanonicalRequest = await sha256Hex(canonicalRequest);
      const stringToSign = [
        'AWS4-HMAC-SHA256',
        amzDate,
        scope,
        hashedCanonicalRequest
      ].join('\n');

      const kDate = await hmacSha256Raw(textEncoder.encode('AWS4' + secretAccessKey), shortDate);
      const kRegion = await hmacSha256Raw(kDate, region);
      const kService = await hmacSha256Raw(kRegion, service);
      const kSigning = await hmacSha256Raw(kService, 'aws4_request');
      const signatureBytes = await hmacSha256Raw(kSigning, stringToSign);
      const signature = [...signatureBytes].map(b => b.toString(16).padStart(2, '0')).join('');

      endpointUrl.search = canonicalQuery + `&X-Amz-Signature=${signature}`;
      return endpointUrl.toString();
    }

    async function loadExistingMusicData() {
      try {
        const r = await fetch('musicas.json', { cache: 'no-store' });
        if (!r.ok) return;
        const data = await r.json();
        state.musicData = {
          albuns: Array.isArray(data.albuns) ? data.albuns : [],
          playlists: Array.isArray(data.playlists) ? data.playlists : [],
          placeholderArtista: data.placeholderArtista || ''
        };
        renderPreview();
      } catch {
        renderPreview();
      }
    }

    function queueItemFromForm() {
      const albumTitle = el.albumTitle.value.trim();
      const trackTitle = el.trackTitle.value.trim();
      const trackArtist = el.trackArtist.value.trim();
      const audio = el.audioFile.files[0] || null;

      if (!albumTitle || !trackTitle || !trackArtist || !audio) {
        setStatus(el.formStatus, '√Ålbum, t√≠tulo, artista e √°udio s√£o obrigat√≥rios.', 'warn');
        return null;
      }

      return {
        id: crypto.randomUUID(),
        albumTitle,
        trackTitle,
        trackArtist,
        files: {
          albumCover: el.albumCoverFile.files[0] || null,
          audio,
          video: el.videoFile.files[0] || null,
          artistImage: el.artistImageFile.files[0] || null
        },
        uploaded: {
          albumCover: '',
          audio: '',
          video: '',
          artistImage: ''
        },
        status: 'pendente'
      };
    }

    function clearForm() {
      el.albumTitle.value = '';
      el.trackTitle.value = '';
      el.trackArtist.value = '';
      el.albumCoverFile.value = '';
      el.audioFile.value = '';
      el.videoFile.value = '';
      el.artistImageFile.value = '';
    }

    function renderQueue() {
      el.queueList.innerHTML = '';
      if (!state.queue.length) {
        el.queueList.innerHTML = '<p class="hint">Fila vazia.</p>';
        return;
      }

      for (const item of state.queue) {
        const div = document.createElement('div');
        div.className = 'queue-item';
        div.innerHTML = `
          <h4>${item.trackTitle} ‚Äî ${item.trackArtist}</h4>
          <small>√Ålbum: ${item.albumTitle}</small>
          <span class="tag">Status: ${item.status}</span>
          ${item.uploaded.audio ? '<span class="tag">√Åudio OK</span>' : ''}
          ${item.uploaded.video ? '<span class="tag">V√≠deo OK</span>' : ''}
          ${item.uploaded.albumCover ? '<span class="tag">Capa OK</span>' : ''}
          ${item.uploaded.artistImage ? '<span class="tag">Imagem Artista OK</span>' : ''}
        `;
        el.queueList.appendChild(div);
      }
    }

    function upsertTrackIntoMusicData(item) {
      let album = state.musicData.albuns.find(a => a.titulo === item.albumTitle);
      if (!album) {
        album = {
          titulo: item.albumTitle,
          capa: item.uploaded.albumCover || '',
          faixas: []
        };
        state.musicData.albuns.push(album);
      }

      if (item.uploaded.albumCover) album.capa = item.uploaded.albumCover;

      const idx = album.faixas.findIndex(f => f.titulo === item.trackTitle && f.artista === item.trackArtist);
      const trackObj = {
        titulo: item.trackTitle,
        artista: item.trackArtist,
        audio: item.uploaded.audio || '',
        video: item.uploaded.video || '',
        imagemArtista: item.uploaded.artistImage || ''
      };

      if (idx >= 0) album.faixas[idx] = trackObj;
      else album.faixas.push(trackObj);
    }

    function renderPreview() {
      el.jsonPreview.textContent = JSON.stringify(state.musicData, null, 2);
    }

    function cloudPath(kind, file, item) {
      const safeAlbum = item.albumTitle.replace(/\s+/g, '-').toLowerCase();
      const safeTrack = item.trackTitle.replace(/\s+/g, '-').toLowerCase();
      const ext = (file.name.split('.').pop() || '').toLowerCase();
      const folder = {
        albumCover: 'covers',
        artistImage: 'artists',
        audio: 'audios',
        video: 'videos'
      }[kind];
      return `${folder}/${safeAlbum}/${safeTrack}-${Date.now()}.${ext}`;
    }

    async function getSignedUpload(kind, file, item) {
      const apiBase = el.apiBase.value.trim();
      if (!apiBase) throw new Error('Configure a Base URL da API primeiro.');

      const path = cloudPath(kind, file, item);
      const r = await fetch(`${apiBase}/sign-upload`, {
        method: 'POST',
        headers: headersWithAuth(true),
        body: JSON.stringify({ path, contentType: file.type || 'application/octet-stream' })
      });

      if (!r.ok) throw new Error(`Falha ao assinar upload (${r.status})`);
      const data = await r.json();
      return {
        uploadUrl: data.uploadUrl,
        publicUrl: data.publicUrl || (el.cdnPrefix.value.trim() ? `${el.cdnPrefix.value.trim()}/${path}` : ''),
        method: data.method || 'PUT',
        headers: data.headers || {}
      };
    }

    async function uploadDirectToCloudflare(kind, file, item) {
      const cfg = getUploadConfig();
      if (!cfg.bucket || !cfg.r2Endpoint || !cfg.r2AccessKeyId || !cfg.r2SecretAccessKey) {
        throw new Error('No modo direto S3, informe Bucket, Endpoint, Access Key ID e Secret Access Key.');
      }

      const path = cloudPath(kind, file, item);
      const presignedUrl = await createR2PresignedPutUrl({
        endpoint: cfg.r2Endpoint,
        bucket: cfg.bucket,
        objectKey: path,
        accessKeyId: cfg.r2AccessKeyId,
        secretAccessKey: cfg.r2SecretAccessKey
      });

      const put = await fetch(presignedUrl, {
        method: 'PUT',
        headers: { 'Content-Type': file.type || 'application/octet-stream' },
        body: file
      });

      if (!put.ok) {
        const t = await put.text().catch(() => '');
        throw new Error(`Upload direto falhou (${put.status}) ${t.slice(0, 200)}`);
      }

      if (!cfg.cdnPrefix) throw new Error('Upload feito, mas falta Prefixo p√∫blico CDN para montar URL final.');
      return `${cfg.cdnPrefix.replace(/\/$/, '')}/${path}`;
    }

    async function uploadFileToCloudflare(kind, file, item) {
      const cfg = getUploadConfig();
      if (cfg.mode === 'direct_s3') return uploadDirectToCloudflare(kind, file, item);

      const signed = await getSignedUpload(kind, file, item);
      if (!signed.uploadUrl) throw new Error('API n√£o retornou uploadUrl.');

      const put = await fetch(signed.uploadUrl, {
        method: signed.method,
        headers: signed.headers,
        body: file
      });

      if (!put.ok) throw new Error(`Upload falhou para ${kind} (${put.status})`);
      return signed.publicUrl;
    }

    async function uploadSingleQueueItem(item) {
      item.status = 'enviando';
      renderQueue();

      const files = item.files;
      if (files.albumCover) item.uploaded.albumCover = await uploadFileToCloudflare('albumCover', files.albumCover, item);
      if (files.audio) item.uploaded.audio = await uploadFileToCloudflare('audio', files.audio, item);
      if (files.video) item.uploaded.video = await uploadFileToCloudflare('video', files.video, item);
      if (files.artistImage) item.uploaded.artistImage = await uploadFileToCloudflare('artistImage', files.artistImage, item);

      upsertTrackIntoMusicData(item);
      item.status = 'conclu√≠do';
      renderQueue();
      renderPreview();
    }

    async function uploadAll() {
      if (!state.queue.length) {
        setStatus(el.uploadStatus, 'Fila vazia.', 'warn');
        return;
      }

      setStatus(el.uploadStatus, 'Upload iniciado...', '');

      let success = 0;
      for (const item of state.queue) {
        try {
          await uploadSingleQueueItem(item);
          success++;
          setStatus(el.uploadStatus, `Enviado ${success}/${state.queue.length}...`, '');
        } catch (err) {
          item.status = `erro: ${err.message}`;
          renderQueue();
          const msg = String(err && err.message || err);
          const friendly = /Failed to fetch/i.test(msg)
            ? 'Falha de rede/CORS. No modo direto use Endpoint S3 + Access Key/Secret e confirme CORS do bucket R2 para seu dom√≠nio.'
            : `Falha no upload: ${msg}`;
          setStatus(el.uploadStatus, friendly, 'warn');
          return;
        }
      }

      setStatus(el.uploadStatus, 'Todos os uploads conclu√≠dos com sucesso.', 'ok');
    }

    function downloadJson() {
      const blob = new Blob([JSON.stringify(state.musicData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'musicas.json';
      a.click();
      URL.revokeObjectURL(url);
    }

    el.saveConfigBtn.onclick = persistConfig;

    el.addQueueBtn.onclick = () => {
      const item = queueItemFromForm();
      if (!item) return;
      state.queue.push(item);
      renderQueue();
      clearForm();
      setStatus(el.formStatus, `Faixa "${item.trackTitle}" adicionada √† fila.`, 'ok');
    };

    el.clearFormBtn.onclick = clearForm;
    el.clearQueueBtn.onclick = () => {
      state.queue = [];
      renderQueue();
      setStatus(el.uploadStatus, 'Fila limpa.', '');
    };

    el.uploadAllBtn.onclick = uploadAll;
    el.refreshPreviewBtn.onclick = renderPreview;
    el.downloadJsonBtn.onclick = downloadJson;

    if (!localStorage.getItem('comusicUploadConfig')) {
      el.uploadMode.value = 'direct_s3';
      el.cfAccountId.value = '3f3d9fcf69cf8db418e97acb119b980a';
      el.cfApiToken.value = '-Fj-NJDsUSeQ_1JuRMeaxU52chrpYmkZeoLpDFsM';
      el.r2Endpoint.value = 'https://3f3d9fcf69cf8db418e97acb119b980a.r2.cloudflarestorage.com';
    }
    loadConfig();
    renderQueue();
    renderPreview();
    loadExistingMusicData();
  </script>
</body>
</html>
